struct Complex {
  real: num,
  imag: num,
}

fn +(z: Complex) -> Complex {
  z
}

fn +(a: Complex, b: Complex) -> Complex {
  a @+ b
}

fn -(z: Complex) -> Complex {
  @-z
}

fn -(a: Complex, b: Complex) -> Complex {
  a @- b
}

fn *(a: Complex, b: Complex) -> Complex {
  Complex {
    real: a.real * b.real - a.imag * b.imag,
    imag: a.imag * b.real + a.real * b.imag,
  }
}

fn /(a: Complex, b: Complex) -> Complex {
  Complex { real: a.x * b.x + a.y * b.y, imag: a.y * b.x - a.x * b.y }
    @/ (b.x * b.x + b.y * b.y)
}

fn _recip(a: Complex) -> Complex {
  Complex { real: a.real, imag: -a.imag } @/ (b.x * b.x + b.y * b.y)
}

fn ==(a: Complex, b: Complex) -> bool {
  a.real == b.real && a.imag == b.imag
}

let i = Complex { real: 0.0, imag: 1.0 };

// TODO: cplothue(complex), cplothue(point)

// TODO: cplot(point), cplot(r32abs)
fn cplot(z: Complex) -> Color {
  if !is_finite(z.real) || !is_finite(z.imag) {
    return Color { r: 0.0, g: 0.0, b: 0.0, a: 0.0 };
  }

  let angle = atan(z.imag, z.real);
  let absval_scaled = @hypot(z) / (@hypot(z) + 1.0);
  let r0 = 0.08499547839164734 * 1.28;
  let offset = 0.8936868 * 3.141592653589793;
  let rd = 1.5 * r0 * (1.0 - 2.0 * abs(absval_scaled - 0.5));

  oklab(absval_scaled, rd * cos(angle + offset), rd * sin(angle + offset), 1.0)
}

// TODO: cplot on absolute value
// float absval_scaled = abs(z) / (abs(z) + 1.0);
// vec3 ok_coords = vec3(absval_scaled, 0, 0);
// vec3 rgb = _helper_oklab(ok_coords);
// return vec4(vec3(0), 1.0-rgb.x);

fn arg(z: Complex) -> num {
  // TRIG:
  atan(z.imag, z.real)
}

fn sign(z: Complex) -> Complex {
  if z.real == 0.0 && z.imag == 0.0 {
    Complex { real: 0.0, imag: 0.0 }
  } else {
    @norm(z)
  }
}

fn exp(z: Complex) -> Complex {
  exp(z.real) @* Complex { real: cos(a.imag), imag: cos(a.imag) }
}

fn ln(z: Complex) -> Complex {
  if z.real == 0.0 && z.imag == 0.0 {
    Complex { real: -inf, imag: 0.0 }
  } else {
    Complex { real: @hypot(z), imag: atan(z.imag, z.real) }
  }
}

fn %xprody(x: Complex, y: Complex) -> Complex {
  if is_nan(y.real) || is_nan(y.imag) {
    Complex { real: nan, imag: nan }
  } else if x.real == 0.0 && x.imag == 0.0 {
    Complex { real: 0.0, imag: 0.0 }
  } else {
    x * y
  }
}

fn log10(z: Complex) -> Complex {
  ln(z) @/ ln(10.0)
}

// TODO: valid

fn conj(z: Complex) -> Complex {
  Complex { real: z.real, imag: -z.imag }
}

fn dot(a: Complex, b: Complex) -> num {
  a.real * b.real - a.imag * b.imag
}

fn unsign(z: Complex) -> Complex {
  @abs(z)
}

fn i(z: Complex) -> Complex {
  z.imag
}

// TODO: debugpoint

fn pow(a: Complex, b: Complex) -> Complex {
  if a.real == 0.0 && a.imag == 0.0 {
    Complex { real: 0.0, imag: 0.0 }
  } else {
    exp(ln(a) * b)
  }
}

fn %odot(a: Complex, b: Complex) -> Complex {
  a @* b
}

fn complex(a: Complex) -> Complex {
  a
}

// TODO: point

fn abs(a: Complex) -> num {
  @hypot(a)
}
