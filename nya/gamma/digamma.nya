//! From @stdlib/math/base/special/digamma/lib/main.js

fn _digamma_asymptotic_polyval(x: num) -> num {
  0.08333333333333333 + x * (-0.008333333333333333 + x * (0.003968253968253968 + x * (-0.004166666666666667 + x * (0.007575757575757576 + x * (-0.021092796092796094 + x * (0.08333333333333333 + x * (-0.4432598039215686)))))))
}

fn _digamma_rateval(x: num) -> num {
  if x == 0.0 {
    return 0.25479851061131553;
  }

  let ax = abs(x);
  if ax <= 1.0 {
    let s1 = 0.25479851061131553 + x * (-0.3255503118680449 + x * (-0.6503185377089651 + x * (-0.28919126444774784 + x * (-0.04525132144873906 + x * (-0.002071332116774595 + x * (0.0))))));
    let s2 = 1.0 + x * (2.076711702373047 + x * (1.4606242909763516 + x * (0.43593529692665967 + x * (0.054151797245674226 + x * (0.0021284987017821146 + x * (-5.578984132167551e-7))))));
    s1 / s2
  } else {
    let x = 1.0 / x;
    let s1 = 0.0 + x * (-0.002071332116774595 + x * (-0.04525132144873906 + x * (-0.28919126444774784 + x * (-0.6503185377089651 + x * (-0.3255503118680449 + x * (0.25479851061131553))))));
    let s2 = -5.578984132167551e-7 + x * (0.0021284987017821146 + x * (0.054151797245674226 + x * (0.43593529692665967 + x * (1.4606242909763516 + x * (2.076711702373047 + x * (1.0))))));
    s1 / s2
  }
}

fn _digamma_rational_approx(x: num) -> num {
  let g = x - 1569415565.0 / 1073741824.0
    - 381566830.0 / 1073741824.0 / 1073741824.0
    - 0.9016312093258695918615325266959189453125e-19;
  let r = _digamma_rateval(x - 1.0);
  g * 0.99558162689208984 + g * r
}

fn digamma(x: num) -> num {
  if is_nan(x) {
    return nan;
  }
  if x == 0.0 {
    return inf_unsigned;
  }

  let mut x = x;
  let mut tmp = if x <= -1.0 {
    x = 1.0 - x;
    let rem = x - round(x);
    if rem == 0.0 {
      return inf_unsigned;
    }
    pi / tan(pi * rem)
  } else {
    0.0
  };

  if x >= 10.0 {
    return (
      tmp
        + {
          let x = x - 1.0;
          let y = ln(x) + 1.0 / (2.0 * x);
          let z = 1.0 / (x * x);
          y - z * _digamma_asymptotic_polyval(z)
        }
    );
  }

  // reduce `x` to (-1,2]; `x` is currently (-1,10), so eight iterations is enough
  for _i in [0, 0, 0, 0, 0, 0, 0, 0]  {
    if x > 2.0 {
      x -= 1.0;
      tmp += 1.0 / x;
    }
  }

  // reduce `x` to [1,2]; `x` is currently (-1,2], so two iterations is enough
  for _i in [0, 0]  {
    if x < 1.0 {
      tmp -= 1.0 / x;
      x += 1.0;
    }
  }

  tmp + _digamma_rational_approx(x)
}
