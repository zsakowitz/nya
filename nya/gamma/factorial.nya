use "complex";
use "gamma/lngamma";

let _nya_cxfact_g = 5.0;
let _nya_cxfact_epsilon = 1e-7;

fn _nya_cxfact_drop_imag(z: Complex) -> Complex {
  if abs(z.imag) <= _nya_cxfact_epsilon {
    Complex { real: z.real, imag: 0.0 }
  } else {
    z
  }
}

fn _nya_helper_cx_factorial_pos(z: Complex) -> Complex {
  let x = 1.0000018972739440364 + 76.180082222642137322 / (z + 1.0)
    - 86.505092037054859197 / (z + 2.0)
    + 24.0128985819226859 / (z + 3.0)
    - 1.2296028490285820771 / (z + 4.0);
  let t = z + _nya_cxfact_g + 0.5;
  sqrt(2.0 * pi) * t ^ (z + 0.5) * exp(-t) * x
}

fn %factorial(z: num) -> num {
  sign_gamma(z + 1.0) * exp(ln_gamma(z + 1.0))
}

fn %factorial(z: Complex) -> Complex {
  if z.real < 1.5 {
    // G(z) = (z-1)!
    // G(z)G(1-z) = π/sin(πz)
    // (z-1)! (1-z-1)! = π/sin(πz)
    // u = z-1
    // u! (-u-1)! = π/sin(πz)
    // u! = π/sin(πz)/(-u-1)!
    // u! = π/(sin(πz)*(-u-1)!)
    let res = -_nya_helper_cx_factorial_pos(-z - 1.0);
    let sinArg = pi * z;
    let sinVal = Complex {
      real: sin(sinArg.real) * cosh(sinArg.imag),
      imag: cos(sinArg.real) * sinh(sinArg.imag),
    };
    pi / (sinVal * res)
  } else {
    _nya_helper_cx_factorial_pos(z)
  }
}

expose package {
  name: "complex factorial",
  default: true,
}
