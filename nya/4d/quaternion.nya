use "complex";
use "components";

struct Quaternion {
  real: num,
  imag: num,
  j: num,
  k: num,
}

fn %display(v: Quaternion) -> latex {
  base(v.real)
    .with_component(display"i", v.imag)
    .with_component(display"j", v.j)
    .with_component(display"k", v.k)
    .finalize
}

fn ->(x: Complex) -> Quaternion {
  Quaternion {
    real: x.real,
    imag: x.imag,
    j: 0.0,
    k: 0.0,
  }
}

fn +(x: Quaternion) -> Quaternion {
  x
}

fn -(x: Quaternion) -> Quaternion {
  @-x
}

fn +(a: Quaternion, b: Quaternion) -> Quaternion {
  a @+ b
}

fn -(a: Quaternion, b: Quaternion) -> Quaternion {
  a @- b
}

fn abs(a: Quaternion) -> num {
  @length(a)
}

fn unsign(a: Quaternion) -> Quaternion {
  @abs(a)
}

fn %odot(a: Quaternion, b: Quaternion) -> Quaternion {
  a @* b
}

fn *(x: Quaternion, y: Quaternion) -> Quaternion {
  let a = x.real;
  let b = x.imag;
  let c = x.j;
  let d = x.k;
  let e = y.real;
  let f = y.imag;
  let g = y.j;
  let h = y.k;

  Quaternion {
    real: a * e - b * f - c * g - d * h,
    imag: a * f + b * e + c * h - d * g,
    j: a * g - b * h + c * e + d * f,
    k: a * h + b * g - c * f + d * e,
  }
}

let j = Quaternion { real: 0.0, imag: 0.0, j: 1.0, k: 0.0 };
let k = Quaternion { real: 0.0, imag: 0.0, j: 0.0, k: 1.0 };

// TODO: point, complex

expose package {
  name: "quaternions",
  default: true,
}
