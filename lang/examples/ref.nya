rule<a, b: float> a + 0.0 => a;
rule d/dx(a * b) => d/dx(a) * b + a * d/dx(b);

rule d/dx(a!x ** b!x) => 0.0;
rule d/dx(a ** b!x) => b * a ** (b - 1);
rule d/dx(a!x ** b) => xprody((d/dx b) * (a ** b), ln(a));
rule d/dx(a ** b) => a ** (b - 1) * (b * d/dx a + xprody(a * d/dx b, ln(a)));

type f32 {
  source js { number }
  source glsl { float }
}

fn some_types() {
  a<b, 45, :sym, { c.q }, d<e<g>>>;
  source { 23 } :: f32;
}

fn hi(a: float, b: ((float))) -> r32 {
  if true {
    c32 { re: 2.0, im: 3.4 }
  } else if 2 + 3 < 4 * 5 | 7 - (8 == 9 % 4) && 2 != 3 && -!4 == ~8 {
    c(a).b(c).re + { 2 + 3 }
  } else if false {
    [2, 3, 89][78](78)<23><45>
  } else {
    7 + 8;
    for a, c in b, d {
      2 + 3
    }
  }
}

fn +(a: float, b: float) -> r32 usage 2 + 3 {
  return;
  return 23;

  break;
  break 'a;
  break 23;
  break 'a 23;

  continue;
  continue 'a;

  match 23 {
    a => 45,
    :hi => 67..45,
    // :arc { a, b } => 78,
  }
}

use "./world";

enum Hi<a, b: float> {
  :a,
  :b { a: i32 },
  :c,
  ..
}

enum Units<a, b: float> -> float {
  :meter => 1.0,
  :cm => 0.01,
  :km => 1000.0,
  ..
}

struct Complex<a, b: float> {
  re: float,
  im: [float; 5, 7, 8]
}

fn array_test<a, b: float>() {
  let x;
  let x: float;
  let x = 2.3;
  let x: float = 2.3;
  [float; 5, 7, 8];
  :a { a: 2, b: 3 };
  .{ a: 2, b: 3 };
  2 ** 3 ** 4;
  a -> b -> c;
}

expose fn sinh "hyperbolic sine" as { arcsinh, arsinh, %"sinh^-1" };
expose type sinh "hyperbolic sine" as { arcsinh, arsinh, %"sinh^-1" };
expose let %"Ï€" "mathematical constant pi": real = 2.0;

fn labels_test() {
  'hi: { a = a + 2 }
  'world: for a in b {}
}

data x: float;
data y: float;

assert 2.0 < 3.0;
