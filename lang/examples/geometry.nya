struct point {
  x: num,
  y: num,
}

fn point(x: num, y: num) -> point {
  point { x, y }
}

struct line {
  p1: point,
  p2: point,
}

fn line(p1: point, p2: point) -> line {
  line { p1, p2 }
}

struct vector {
  p1: point,
  p2: point,
}

fn vector(p1: point, p2: point) -> vector {
  vector { p1, p2 }
}

struct segment {
  p1: point,
  p2: point,
}

fn segment(p1: point, p2: point) -> segment {
  segment { p1, p2 }
}

struct ray {
  p1: point,
  p2: point,
}

fn ray(p1: point, p2: point) -> ray {
  ray { p1, p2 }
}

struct arc {
  p1: point,
  p2: point,
  p3: point,
}

fn arc(p1: point, p2: point, p3: point) -> arc {
  arc { p1, p2, p3 }
}

struct angle {
  p1: point,
  p2: point,
  p3: point,
}

fn angle(p1: point, p2: point, p3: point) -> angle {
  angle { p1, p2, p3 }
}

struct directed_angle {
  p1: point,
  p2: point,
  p3: point,
}

fn directed_angle(p1: point, p2: point, p3: point) -> directed_angle {
  directed_angle { p1, p2, p3 }
}

fn distance(p1: point, p2: point) -> num {
  @length(p1 @- p2)
}
// line-point distance

fn length(s: segment) -> num {
  distance(s.p1, s.p2)
}

fn glider(pt: line, at: num) -> point {
  @mix(pt.p1, pt.p2, at)
}

fn start(v: vector) -> point {
  v.p1
}

fn end(v: vector) -> point {
  v.p2
}

fn anglebisector(v: angle) -> ray {
  ray {
    p1: v.p2,
    p2: @norm(@norm(v.p1 @- v.p2) @+ @norm(v.p3 @- v.p2)) @+ v.p2,
  }
}

// maybe use an @as primitive?
fn anglebisector(v: directed_angle) -> ray {
  ray {
    p1: v.p2,
    p2: @norm(@norm(v.p1 @- v.p2) @+ @norm(v.p3 @- v.p2)) @+ v.p2,
  }
}

// circle
// polygon
//
// "center"
// "circle"
// "distance"
// "glider"
// "intersection"
// "midpoint"
// "parallel"
// "perpendicular"
// "polygon"
// "radius"
// "segments"
// "vertices"
// "angles"
// "directed angles"
// "perpendicular bisector"
// "translate"
// "rotate"
// "dilate"
// "reflect"
// "perimeter"

fn main() -> ray {
  anglebisector(angle(point(2.0, 3.0), point(7, -4), point(3.5, -1)))
}
