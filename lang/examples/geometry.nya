struct Point {
  x: num,
  y: num,
}

fn point(x: num, y: num) -> Point {
  Point { x, y }
}

// Special syntax to declare multiple structs with the exact same layout.
// Especially useful for geometry functions, which are polymorphic over the
// various types of line and angle.
struct Line, Vector, Segment, Ray {
  p1: Point,
  p2: Point,
}

type AnyLine = Line | Segment | Ray;
type AnySlope = Line | Vector | Segment | Ray;

fn line(p1: Point, p2: Point) -> Line {
  Line { p1, p2 }
}

fn vector(p1: Point, p2: Point) -> Vector {
  Vector { p1, p2 }
}

fn segment(p1: Point, p2: Point) -> Segment {
  Segment { p1, p2 }
}

fn ray(p1: Point, p2: Point) -> Ray {
  Ray { p1, p2 }
}

struct Arc {
  p1: Point,
  p2: Point,
  p3: Point,
}

fn arc(p1: Point, p2: Point, p3: Point) -> Arc {
  Arc { p1, p2, p3 }
}

struct Angle, DirectedAngle {
  p1: Point,
  p2: Point,
  p3: Point,
}

type AnyAngle = Angle | DirectedAngle;

fn angle(p1: Point, p2: Point, p3: Point) -> Angle {
  Angle { p1, p2, p3 }
}

fn directed_angle(p1: Point, p2: Point, p3: Point) -> DirectedAngle {
  DirectedAngle { p1, p2, p3 }
}

fn distance(p1: Point, p2: Point) -> num {
  @length(p1 @- p2)
}

//! https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
fn distance(l: Line, p: Point) -> num {
  let x1 = l.p1.x;
  let y1 = l.p1.y;
  let x2 = l.p2.x;
  let y2 = l.p2.y;

  let x0 = p.x;
  let y0 = p.y;

  abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1)
    / distance(l.p1, l.p2)
}

fn distance(p: Point, l: Line) -> num {
  distance(l, p)
}

fn length(s: Segment | Vector) -> num {
  distance(s.p1, s.p2)
}

fn glider(pt: Line, at: num) -> Point {
  @mix(pt.p1, pt.p2, at)
}

fn start(v: Vector) -> Point {
  v.p1
}

fn end(v: Vector) -> Point {
  v.p2
}

fn anglebisector(v: AnyAngle) -> Ray {
  Ray {
    p1: v.p2,
    p2: @norm(@norm(v.p1 @- v.p2) @+ @norm(v.p3 @- v.p2)) @+ v.p2,
  }
}

fn midpoint(s: Segment) -> Point {
  @mix(s.p1, s.p2, 0.5)
}

fn midpoint(p1: Point, p2: Point) -> Point {
  @mix(p1, p2, 0.5)
}

struct Circle {
  center: Point,
  radius: num,
}

fn circle(center: Point, radius: num) -> Circle {
  Circle { center, radius }
}

fn circle(center: Point, point_on_radius: Point) -> Circle {
  Circle { center, radius: distance(center, point_on_radius) }
}

fn parallel(l: Line | Segment | Vector | Ray, p: Point) -> Line {
  Line { p1: p, p2: p @+ l.p2 @- l.p1 }
}

fn perpendicular(l: AnySlope, p: Point) -> Line {
  Line {
    p1: p,
    p2: Point { x: p.x + l.p2.y - l.p1.y, y: p.y + l.p1.x - l.p2.x },
  }
}

fn intersection(l1: AnyLine, l2: AnyLine) -> Point {
  let x1 = l1.p1.x;
  let y1 = l1.p1.y;
  let x2 = l1.p2.x;
  let y2 = l1.p2.y;

  let x3 = l2.p1.x;
  let y3 = l2.p1.y;
  let x4 = l2.p2.x;
  let y4 = l2.p2.y;

  let d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

  let x1y2 = x1 * y2;
  let x2y1 = y1 * x2;
  let x3y4 = x3 * y4;
  let x4y3 = y3 * x4;

  let base = Point {
    x: (x1y2 - x2y1) * (x3 - x4) - (x1 - x2) * (x3y4 - x4y3),
    y: (x1y2 - x2y1) * (y3 - y4) - (y1 - y2) * (x3y4 - x4y3),
  };

  // TODO: optimize this as a determinant call
  base @/ d
}

//! https://stackoverflow.com/a/37225895
// `which` should be -1 | 1
fn _intersection(l: AnyLine, c: Circle, which: num) -> Point {
  let cx = c.center.x;
  let cy = c.center.y;
  let r = c.radius;

  let x1 = l.p1.x;
  let y1 = l.p1.y;
  let x2 = l.p2.x;
  let y2 = l.p2.y;

  let v1 = l.p2 @- l.p1;
  let v2 = l.p1 @- c.center;

  let b = -2.0 * (v1.x * v2.x + v1.y * v2.y);
  let c = 2.0 * (v1.x * v1.x + v1.y * v1.y);
  let d = sqrt(b * b - 2.0 * c * (v2.x * v2.x + v2.y * v2.y - r * r));

  if is_nan(d) {
    point(nan, nan)
  } else {
    l.p1 @+ v1 @* ((b + which * d) / c)
  }
}

// `which` should be -1 | 1
fn _intersection(c1: Circle, c2: Circle, which: num) -> Point {
  let x0 = c1.center.x;
  let y0 = c1.center.y;
  let r0 = c1.radius;

  let x1 = c2.center.x;
  let y1 = c2.center.y;
  let r1 = c2.radius;

  let dx = x1 - x0;
  let dy = y1 - y0;
  // TODO: dot product
  let d = sqrt(dx * dx + dy * dy);

  // circles do not intersect
  if d > r0 + r1 || d < abs(r0 - r1) || d == 0 && r0 == r1 {
    point(nan, nan)
  } else {
    // dot product
    let a = (r0 * r0 - r1 * r1 + d * d) / (2 * d);
    let h = sqrt(r0 * r0 - a * a);
    c1.center @+ point(-dy, dx) @* (which * h / d) @+ point(dx, dy) @* (a / d)
  }
}

fn perpendicular_bisector(p1: Point, p2: Point) -> Line {
  let l1a = midpoint(p1, p2);
  let l1b = point(l1a.x + (p2.y - p1.y), l1a.y - (p2.x - p1.x));
  Line { p1: l1a, p2: l1b }
}

fn perpendicular_bisector(s: Segment) -> Line {
  perpendicular_bisector(s.p1, s.p2)
}

fn circle(arc: Arc) -> Circle {
  let p1 = arc.p1;
  let p2 = arc.p2;
  let p3 = arc.p3;

  let c = intersection(
    perpendicular_bisector(p1, p2),
    perpendicular_bisector(p3, p2),
  );

  Circle { center: c, radius: @length(c @- p1) }
}

fn intersection(c: Circle, l: AnyLine) -> Point {
  _intersection(l, c, 1)
}

fn intersection(l: AnyLine, c: Circle) -> Point {
  _intersection(l, c, -1)
}

fn intersection(a: Circle, b: Circle) -> Point {
  _intersection(a, b, 1)
}

fn glider(a: Circle, at: num) -> Point {
  let at = clamp(at, 0.0, 1.0);
  Point { x: a.center.x + cos(2 * pi * at), y: a.center.y + sin(2 * pi * at) }
}

fn glider(l: Line, at: num) -> Point {
  @mix(l.p1, l.p2, at)
}

fn glider(l: Ray, at: num) -> Point {
  @mix(l.p1, l.p2, max(0.0, at))
}

fn glider(l: Segment, at: num) -> Point {
  @mix(l.p1, l.p2, clamp(at, 0.0, 1.0))
}

// "glider"
// "intersection"
// "polygon"
// "segments"
// "vertices"
// "angles"
// "directed angles"
// "translate"
// "rotate"
// "dilate"
// "reflect"
// "perimeter"

fn main() -> Line {
  let A = point(-5.28, 0.84);
  let B = point(-2.64, 1.40);
  let C = point(-0.47, 0.75);
  let a = line(A, B);
  let b = circle(C, 3.0);
  perpendicular_bisector(A, B)
}
