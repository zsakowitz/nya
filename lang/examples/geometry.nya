struct Point {
  x: num,
  y: num,
}

fn point(x: num, y: num) -> Point {
  Point { x, y }
}

// Special syntax to declare multiple structs with the exact same layout.
// Especially useful for geometry functions, which are polymorphic over the
// various types of line and angle.
struct Line, Vector, Segment, Ray {
  p1: Point,
  p2: Point,
}

type AnyLine = Line | Vector | Segment | Ray;

fn line(p1: Point, p2: Point) -> Line {
  Line { p1, p2 }
}

fn vector(p1: Point, p2: Point) -> Vector {
  Vector { p1, p2 }
}

fn segment(p1: Point, p2: Point) -> Segment {
  Segment { p1, p2 }
}

fn ray(p1: Point, p2: Point) -> Ray {
  Ray { p1, p2 }
}

struct Arc {
  p1: Point,
  p2: Point,
  p3: Point,
}

fn arc(p1: Point, p2: Point, p3: Point) -> Arc {
  Arc { p1, p2, p3 }
}

struct Angle, DirectedAngle {
  p1: Point,
  p2: Point,
  p3: Point,
}

type AnyAngle = Angle | DirectedAngle;

fn angle(p1: Point, p2: Point, p3: Point) -> Angle {
  Angle { p1, p2, p3 }
}

fn directed_angle(p1: Point, p2: Point, p3: Point) -> DirectedAngle {
  DirectedAngle { p1, p2, p3 }
}

fn distance(p1: Point, p2: Point) -> num {
  @length(p1 @- p2)
}
// line-point distance

fn length(s: Segment | Vector) -> num {
  distance(s.p1, s.p2)
}

fn glider(pt: Line, at: num) -> Point {
  @mix(pt.p1, pt.p2, at)
}

fn start(v: Vector) -> Point {
  v.p1
}

fn end(v: Vector) -> Point {
  v.p2
}

fn anglebisector(v: AnyAngle) -> Ray {
  Ray {
    p1: v.p2,
    p2: @norm(@norm(v.p1 @- v.p2) @+ @norm(v.p3 @- v.p2)) @+ v.p2,
  }
}

fn midpoint(s: Segment) -> Point {
  @mix(s.p1, s.p2, 0.5)
}

struct Circle {
  center: Point,
  radius: num,
}

fn circle(center: Point, radius: num) -> Circle {
  Circle { center, radius }
}

fn circle(center: Point, point_on_radius: Point) -> Circle {
  Circle { center, radius: distance(center, point_on_radius) }
}

fn parallel(l: AnyLine, p: Point) -> Line {
  Line { p1: p, p2: l.p2 @- l.p1 @+ p }
}

fn perpendicular(l: AnyLine, p: Point) -> Line {
  Line {
    p1: p,
    p2: Point { x: p.x + l.p2.y - l.p1.y, y: p.y + l.p1.x - l.p2.x },
  }
}

fn intersection(l1: AnyLine, l2: AnyLine) -> Point {
  let x1 = l1.p1.x;
  let y1 = l1.p1.y;
  let x2 = l1.p2.x;
  let y2 = l1.p2.y;

  let x3 = l2.p1.x;
  let y3 = l2.p1.y;
  let x4 = l2.p2.x;
  let y4 = l2.p2.y;

  let x1y2 = x1 * y2;
  let x2y1 = y1 * x2;
  let x3y4 = x3 * y4;
  let x4y3 = y3 * x4;

  let base = Point {
    x: (x1y2 - x2y1) * (x3 - x4) - (x1 - x2) * (x3y4 - x4y3),
    y: (x1y2 - x2y1) * (y3 - y4) - (y1 - y2) * (x3y4 - x4y3),
  };

  // TODO: optimize this as a determinant call
  base @/ ((x1 - x2) * (y3 - y4) - (y1 - y3) * (x3 - x4))
}

//! https://stackoverflow.com/a/37225895
// `which` should be -1 | 1
fn intersection(l: AnyLine, c: Circle, which: num) -> Point {
  let cx = c.center.x;
  let cy = c.center.y;
  let r = c.radius;

  let x1 = l.p1.x;
  let y1 = l.p1.y;
  let x2 = l.p2.x;
  let y2 = l.p2.y;

  let v1 = l.p2 @- l.p1;
  let v2 = l.p1 @- c.center;

  let b = -2.0 * (v1.x * v2.x + v1.y * v2.y);
  let c = 2.0 * (v1.x * v1.x + v1.y * v1.y);
  let d = sqrt(b * b - 2.0 * c * (v2.x * v2.x + v2.y * v2.y - r * r));

  if is_nan(d) {
    point(nan, nan)
  } else {
    l.p1 @+ v1 @* ((b + which * d) / c)
  }
}

// circle
// polygon

// "circle"
// "distance"
// "glider"
// "intersection"
// "polygon"
// "segments"
// "vertices"
// "angles"
// "directed angles"
// "perpendicular bisector"
// "translate"
// "rotate"
// "dilate"
// "reflect"
// "perimeter"

fn main() -> Point {
  let a = point(2.0, 3.0);
  let b = point(7.0, -4.0);
  let c = point(3.5, -1.0);
  let d = point(5.0, 2.0);
  let e = point(-9.0, -6.0);
  line(a, b).intersection(circle(c, d), 1)
}
