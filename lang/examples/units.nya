// All possible basic unit categories; conversion is done via these.
enum UnitCategory {
  :m,
  :s,
  :mol,
  :A,
  :K,
  :kg,
  :cd,
}

struct UnitMappingOne {
  base: UnitCategory,
  exp: real,
}

// A mapping from a named unit to a set of universal unit categories.
struct UnitMapping {
  // 'bases' is an array with unknown length; it can only be operated on at
  // compile time.
  bases: [UnitMappingOne; ..],
  scale: real,
}

fn um(category: UnitCategory, scale: real) -> UnitMapping {
  .{ [.{ category, 1.0 }], scale }
}

fn um(category: UnitCategory) -> UnitMapping {
  .{ [.{ category, 1.0 }], 1.0 }
}

fn um(category: [UnitMappingOne; ..]) -> UnitMapping {
  .{ category, 1.0 }
}

fn um(category: [UnitMappingOne; ..], scale: real) -> UnitMapping {
  .{ category, scale }
}

enum UnitName -> UnitMapping {
  :m => um(:m),
  :s => um(:s),
  :g => um(:kg, 1e-3),
  :kg => um(:kg),
  :min => um(:s, 60.0),
  :hr => um(:s, 3600.0),
  :N => um([.{ :kg, 1.0 }, .{ :m, 1.0 }, .{ :s, -2.0 }]),
  :J => um([.{ :kg, 1.0 }, .{ :m, 2.0 }, .{ :s, -2.0 }]),
  :cal => um([.{ :kg, 1.0 }, .{ :m, 2.0 }, .{ :s, -2.0 }], 4.184.inv),
}

struct UnitSingle {
  name: UnitName,
  exp: real,
}

struct Unit {
  of: [UnitSingle; ..],
}

struct UnitBases {
  m: real,
  s: real,
  mol: real,
  A: real,
  K: real,
  kg: real,
  cd: real,
}

struct UnitBase {
  bases: UnitBases,
  scale: real,
}

fn unit_bases(unit: Unit) -> UnitBase {
  let bases = @zero(UnitBases);
  let scale = 1.0;

  for u in unit.of {
    let mapping = UnitName(u.name);
    for entry in mapping.bases {
      let exp = entry.exp * u.exp;
      scale = scale * entry.scale ** exp;
      match entry.base {
        :m => bases.m = bases.m + exp,
        :s => bases.s = bases.s + exp,
        :mol => bases.mol = bases.mol + exp,
        :A => bases.A = bases.A + exp,
        :K => bases.K = bases.K + exp,
        :kg => bases.kg = bases.kg + exp,
        :cd => bases.cd = bases.cd + exp,
      }
    }
  }

  .{ bases, scale }
}

fn conversion_factor(src: Unit, dst: Unit) -> real {
  let b_src = unit_bases(src);
  let b_dst = unit_bases(dst);
  assert b_src.bases == b_dst.bases else "incompatible units";
  b_src.scale / b_dst.scale
}

struct RealWithUnit {
  value: real,
  unit: Unit,
}

fn +(a: RealWithUnit, b: RealWithUnit) -> RealWithUnit {
  let scale = conversion_factor(b.unit, a.unit);
  .{ a.unit, a + b * scale }
}

expose type RealWithUnit "a real number with a unit attached";
expose fn + "add two values with units";
