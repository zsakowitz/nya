enum Hi<a, b: float> {
  :a,
  :b { a: i32 },
  :c { a: i32, d: f32 },
  :d
}

enum Hi<a, b: float> {
..
}

enum Hi<a, b: float> {
}

enum Hi<a, b: float> {
  :a,
  :b { a: i32 },
  :c { a: i32, d: f32 },
  :d,
  ..
}

fn hard_to_print() usage (a{b:2}) {
  if (a{b:2}) {23}
  'a: for a in (b {c:2}) {23}
  for a, b, c, d, e, f, g, h in 45942364872364876235487623548762354762354e76423547625374652374652374834592348654,45942364872364876235487623548762354762354e76423547625374652374652374834592348654,45942364872364876235487623548762354762354e76423547625374652374652374834592348654,45942364872364876235487623548762354762354e76423547625374652374652374834592348654, {}

  

  match 23 {
    a => 45,
    :hi => 67..45,
    :hi => 67..(2+45),
    :hi => (2+67)..45,
    :hi => ..45,
    :hi => 67..,
    :hi => ..,
    :arc { a, b: :world } => 78,
    .{ a: 23, b } => 78,
    45 => 9,
    4.5 => 9,
    false=>8,
  }
}

rule<a, b: float> $a + 0.0 => $a;
rule d/dx($a * $b) => d/dx $a * $b + $a * d/dx $b;

rule {
  d/dx($a!x ** $b!x) => 0.0;
  d/dx($a ** $b!x) => $b * $a ** ($b - 1);
  d/dx($a!x ** $b) => xprody((d/dx $b) * ($a ** $b), ln(a));
  d/dx($a ** $b) => $a ** ($b - 1) * ($b * d/dx $a + xprody($a * d/dx $b, ln($a)));
}

type f32 {
  source js { number }
  source glsl { float }
}

fn some_types() {
  a<b, 45, :sym, { c.q }, d<e<g>>>;
  source { 23 } :: f32;
  source js { 2$(x)3 } source glsl { 45 } :: f32;
}

fn hi(a: float, b: ((float))) -> r32 {
  if 2 { 3} else{4}
  if true {
    c32 { re: 2.0, im: 3.4 }
  } else if 2 + 3 < 4 * 5 | 7 - (8 == 9 % 4) && 2 != 3 && -!4 == ~8 {
    c(a).b(c).re + { 2 + 3 }
  } else if false {
    [2, 3, 89][78](78)<23><45>
  } else {
    7 + 8;
    for a, c in b, d {
      2 + 3
    }
  }
}

fn +(a: float, b: float) -> r32 usage 2 + 3,4+548754623498746293874692387934872639847 {
  return;
  return 23;

  break;
  break 'a;
  break 23;
  break 'a 23;

  continue;
  continue 'a;

  match 23 {
    a => 45,
    :hi => 67..45,
  }
}

use "./world";

enum Units<a, b: float> -> float {
  :meter => 1.0,
  :cm => 0.01,
  :km => 1000.0,
  ..
}

struct Complex<a, b: float> {
  re: float,
  im: [float<float<{2+3}>>; 5, 7, 8]
}

fn array_test<a, b: float>() {
  let x;
  let x: float;
  let x = 2.3;
  let x: float = 2.3;
  [float; 5, 7, 8];
  :a { a: 2, b: 3 };
  .{ a: 2, b: 3 };
  2 ** 3 ** 4;
  a -> b -> c;
}

expose fn sinh as { arcsinh, arsinh, %"sinh^-1" } "hyperbolic sine";

expose {
  type complex  as c32"complex number";
  let %"Ï€" "mathematical constant pi": real = 2.0;
}

fn labels_test() {
  'hi: { a = a + 2 }
  'world: for a in b {}
}

data x: float;
data y: float;

assert 2.0 < 3.0;
assert 2.0 < 3.0 else "world";
