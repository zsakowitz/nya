// Multiple files
use "./bool"

// TypeScript and GLSL output
type f32 "real number" {
  source js { number }
  source glsl { float }
}

// `let` specifies how to initialize a value of this type in `let` statements
let f32 {
  source js { 0 }
  source glsl { 0.0 }
}

type u32 "positive integer" {
  source js { number }
  source glsl { uint }
}

let u32 {
  source js { 0 }
  source glsl { 0.0 }
}

// Compound types
struct c32 "complex number" = @vec2(f32);
struct viewport "viewport" = @vec4(c32);

// Values received from JS and GLSL uniforms
uniform vp: viewport;

// Inline function labels
fn + "adds two values";
fn unique "returns a list with duplicates removed";

// Operator overloading
fn +(a: f32, b: f32) -> f32 {
  source { $(a) + $(b) }
}

// GLSL textures
resource img "raw image data" {
  source js { ImageData }
  source glsl { texture2D }
}

// Generic types
struct point32<N: u32> "$(N)d point" = @vec<N>(f32);

// Comprehensions
fn +<N: u32>(pa: point32<N>, pb: point32<N>) -> point32<N> {
  if 1 < N < 4 {
    only glsl {
      return source glsl { $(pa) + $(pb) }
    }
  }

  a + b for a, b = pa, pb
}

// Arrays with unknown (but capped) length
fn unique<N: u32>(a: f32[N]) -> f32[..N] {
  let ret: f32[N];
  let len: u32;

  'outer: for el = a {
    for i = 0..N {
      if i >= len {
        break
      }
      if ret[i] == el {
        break 'outer
      }
    }
    ret[len] = el
    len += 1
  }

  // `array @ len` syntax specifies an actual length for a bounded array
  ret @ len
}

// Symbolic computation can be specified
deriv +(a, b) {
  deriv(a) + deriv(b)
}

deriv *(a, b) {
  deriv(a) * b + a * deriv(b)
}

simplify +(a: f32, b) {
  if a == 0.0 {
    b
  } else {
    a + b
  }
}

simplify +(a, b: f32) {
  if b == 0.0 {
    a
  } else {
    a + b
  }
}

// Imports from JavaScript
type mathjscx "mathjs complex number" {
  source js { import("mathjs").Complex | number }
  // no source glsl means this isn't accessible from GLSL
}

// Type coercion operator
// In the case of split graphs (A->B, A->C, B->D, C->D, first "use" take precedence)
fn |=>(a: mathjscx) -> c32 {
  c32(
    source js { typeof $(a) == 'number' ? $(a) : $(a).re },
    source js { typeof $(a) == 'number' ? 0 : $(a).im }
  )
}

fn mathjscx(a: c32) -> mathjscx {
  using js { import { Complex } from "mathjs"; }
  source js { Complex($(a.re), $(a.im)) }
}

fn gamma(a: c32) -> c32 {
  only js {
    // 'using' declares imports which must go outside function scope
    using js { import { gamma } from "mathjs"; }
    // return type of 'source' is assumed to match fn return type; we explicitly
    // mark it as a mathjscx so automatic coercion works
    source { gamma($(mathjscx(a))) } :: mathjscx
  }
}
